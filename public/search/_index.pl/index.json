[{"categories":null,"content":"Town of Salem\ris an online multiplayer social deduction video game based on the Mafia\rparty game. The game is characterized by rapid rounds of quick judgements and information asymmetries. Confusion is a resource, strategy is a sword, and expectation is a weakness. Being able to review previous games and study how each choice you made determined your opportunities and outcomes would be of great advantage in refining game skill.\nAssessment The Steam distribution of the game is written in the Unity\rgame engine and compiled into .NET assemblies which are loaded and executed by the engine at runtime. This means that we\u0026rsquo;re able to decompile the game code with nearly one-to-one accuracy. Owing to the high success rate of lossless transpiling of Intermediate Language bytecode, many games written in Unity opt to obfuscate their release assemblies, especially since many development teams choose to externalize costs at the expense of the players by making cheating both possible and easy.\nUpon reviewing the primary assembly for Town of Salem, no obfuscation is employed. The networking code is engineered to prevent players from exploiting the game with client-side modifications. This is valuable in our case, as it means that we\u0026rsquo;ll be able to record network traffic during live games and simply feed everything back in later. Effectively no interaction on the client is necessary to progress the state of the game. Additionally, the lack of obfuscation will make the general task of writing a mod much easier.\nTechnical Approach I\u0026rsquo;ve opted to use an existing modding framework called BepInEx\r. It utilizes DLL hijacking to perform the necessary redirections, which is important as it means we\u0026rsquo;ll almost never need to update the mod or re-patch existing files after a game update. It also provides a custom patching library\r, which will allow me to easily patch the network management code. I\u0026rsquo;ll also be working from the GUI system referenced in my previous post\r.\nNetwork Overview The networking layer is directed through a small class TOSNetworkService. This class is responsible for managing the lifetime of the TCP socket, testing the health of the connection, and serializing/deserializing network traffic. The latter task is the most relevant, since I\u0026rsquo;ll want to both save raw game traffic to disk and prevent the client from attempting to send traffic during replay playback.\npublic class TOSNetworkService : INetworkService { // ... public void ProcessMessages(byte[] data) {} public void SendMessage(Client.BaseMessage msg) {} // ... } Since the networking protocol is so straightforward, the reverse-engineering part of the project is over almost instantly.\nBuilding the Perfect Beast I only need a few points of interface for replay management, so I\u0026rsquo;ll start by defining those externally-accessible methods immediately.\nstatic class Replay { public static bool IsRecording { get; private set; } public static bool IsPlaybackActive { get; private set; } public static bool IsPlaybackPaused { get; private set; } public static void OnServerPacket(byte[] data); public static void StartPlayback(String filePath); public static void StopPlayback(); public static void TogglePlayback(); } The requisite patches are very simple:\n[HarmonyPatch(typeof(TOSNetworkService))] class PatchTOSNetworkService { [HarmonyPatch(nameof(TOSNetworkService.ProcessMessages))] [HarmonyPatch(new Type[] { typeof(byte[]) })] [HarmonyPrefix] public static void PrefixProcessMessages(ref byte[] data) { Replay.OnServerPacket(data); } [HarmonyPatch(nameof(TOSNetworkService.SendMessage))] [HarmonyPatch(new Type[] { typeof(BaseMessage) })] [HarmonyPrefix] public static bool PrefixSendMessage(ref BaseMessage msg) { // suppress outbound network traffic when replay files are loaded return !Replay.IsPlaybackActive; } } Recording Format For recording, I need to capture an array of raw network messages with the time in milliseconds after the start of the recording that they were received. The playback mechanism is simple: start a timer and check the packet queue each game tick to determine if the next packet should be processed according to its stored delay. Fine-grained playback control can be further built on top of that core system later.\n// ... in Replay.cs private struct ReceivedPacket { public long millisecondDelay; public String payloadBase64; } private struct Recording { public long startTimeUnixMilli; public long lengthInMilliseconds; public List\u0026lt;ReceivedPacket\u0026gt; packets; } private static DateTime startTime; private static Stopwatch stopwatch = new Stopwatch(); private static List\u0026lt;ReceivedPacket\u0026gt; packetLog; I want to automatically begin recording each time a game starts and stop recording when it ends. That\u0026rsquo;s simple: I can watch the packet stream to capture these events.\n// ... in Replay.cs public static void OnServerPacket(byte[] data) { if (IsPlaybackActive) { return; } MessageType messageType = (MessageType) data[0]; if (messageType == MessageType.CreateLobby) { StartRecording(); } if (IsRecording) { packetLog.Add(new ReceivedPacket() { millisecondDelay = stopwatch.ElapsedMilliseconds, payloadBase64 = Convert.ToBase64String(data, Base64FormattingOptions.None) }); } if (messageType == MessageType.ReturnToHome) { StopRecording(); } } Wonderful! The simplicity of the network protocol implementation means that I don\u0026rsquo;t have to worry anything like frame delimitation, which can get very complicated depending on the composition of the protocol.\nSaving and Loading Next up, serializing the recording and writing to disk. I could come up with a low-level format to store recordings in a space-efficient manner, but it won\u0026rsquo;t be a cost-effective use of my time. The network protocol is already rather sparse, since there\u0026rsquo;s nothing to communicate except the bare gameplay fundamentals. It would also make further changes to the recording format somewhat frustrating. By using JSON, I\u0026rsquo;m able to use existing libraries to serialize and deserialize C# objects in a flash while ignoring object fields that are not present in a given recording file. Simple code is more flexible and less prone to failure!\n// ... in Replay.cs private static void StopRecording() { if (!IsRecording) { return; } // determine file name TimeSpan epochTimeSpan = startTime.ToUniversalTime() - new DateTime(1970, 1, 1); long epochMillis = (long) epochTimeSpan.TotalMilliseconds; var fileName = String.Format(\u0026#34;replay/{0}.json\u0026#34;, epochMillis); // populate the recording struct Recording recording = new Recording(); recording.startTimeUnixMilli = epochMillis; recording.lengthInMilliseconds = (long) DateTime.Now.Subtract(startTime).TotalMilliseconds; recording.packets = packetLog; // serialize the recording and write to disk Directory.CreateDirectory(\u0026#34;replay\u0026#34;); string json = Newtonsoft.Json.JsonConvert.SerializeObject(recording); File.WriteAllText(fileName, json); IsRecording = false; } private static void StartRecording(String filePath) { Recording recording = Newtonsoft.Json.JsonConvert.DeserializeObject\u0026lt;Recording\u0026gt;(File.ReadAllText(filePath)); // ... } Emulating Realtime Playback Earlier, I said the phrase \u0026ldquo;packet queue\u0026rdquo; as a means of conceptualizing the received server traffic, so I\u0026rsquo;ll create a Queue\u0026lt;ReceivedPacket\u0026gt; to store packets from the loaded recording file. Since each packet is stored with the millisecond delay it was received after recording, and since each packet was serialized in the order it was received, emulating linear playback is simply a matter of checking the packet at the front of the queue and comparing it to the playback timer.\n// ... in Replay.cs private static Queue\u0026lt;ReceivedPacket\u0026gt; replayablePackets = new Queue\u0026lt;ReceivedPacket\u0026gt;(); public static void StartPlayback(String filePath) { Recording recording = Newtonsoft.Json.JsonConvert.DeserializeObject\u0026lt;Recording\u0026gt;(File.ReadAllText(filePath)); replayablePackets.Clear(); foreach (ReceivedPacket packet in recording.packets) { replayablePackets.Enqueue(packet); } stopwatch.Restart(); playbackOffset = 0; IsPlaybackActive = true; IsPlaybackPaused = false; } private static void TickPlayback() { while (replayablePackets.Count \u0026gt; 0 \u0026amp;\u0026amp; replayablePackets.Peek().millisecondDelay \u0026lt;= stopwatch.ElapsedMilliseconds { ReceivedPacket packet = replayablePackets.Dequeue(); byte[] data = Convert.FromBase64String(packet.payloadBase64); TOSNetworkService networkService = (TOSNetworkService) GlobalServiceLocator.Instance.NetworkService; networkService.ProcessMessages(data); } } I also mentioned checking the packet queue each game tick, so I\u0026rsquo;ll need to utilize my BepInLoader class (which extends Unity\u0026rsquo;s MonoBehavior class, and is thus integrated into the engine\u0026rsquo;s ECS implementation) to execute the playback logic in the main thread.\npublic class BepInLoader : BaseUnityPlugin { // ... public static event Action OnUpdate; private void Update() { if (OnUpdate != null) { OnUpdate(); } } } static class Replay { // ... public static void StartPlayback() { // ... BepInLoader.OnUpdate += TickPlayback; } public static void StopPlayback() { // ... BepInLoader.OnUpdate -= TickPlayback; } } Further Tweaks With all of this done, simple playback works better than I had expected. I was able to toggle the playback state by simply stopping and starting the Stopwatch object, but sometimes there are long pauses that I\u0026rsquo;d rather skip. I need to come up with a way to skip the timer ahead so that I can force the next packet to be processed immediately.\nSince the Stopwatch class doesn\u0026rsquo;t expose any methods to modify the time, I\u0026rsquo;ll have to track the time offset independently.\n// ... in Replay.cs private static Queue\u0026lt;ReceivedPacket\u0026gt; replayablePackets = new Queue\u0026lt;ReceivedPacket\u0026gt;(); private static long playbackOffset = 0; public static void SkipPacket() { if (PlaybackActive \u0026amp;\u0026amp; replayablePackets.Count \u0026gt; 0) { ReceivedPacket packet = replayablePackets.Peek(); playbackOffset = packet.millisecondDelay - stopwatch.ElapsedMilliseconds; } } private static void TickPlayback() { while (replayablePackets.Count \u0026gt; 0 \u0026amp;\u0026amp; replayablePackets.Peek().millisecondDelay \u0026lt;= (stopwatch.ElapsedMilliseconds + playbackOffset)) { // ... } } Initially, I ran into a bug with this approach where the playback seemed to jump ahead much further than expected. It wasn\u0026rsquo;t quite until I realized that the problem worsened during later playback time that I realized my issue: I had forgotten to compensate for the amount of time that had already elapsed. Simply subtracting stopwatch.ElapsedMilliseconds from packet.millisecondDelay corrected the issue.\nFinal Improvement Now that recording and playback are working without issue, I\u0026rsquo;m able to review previous games and study my mistakes. Yet, there\u0026rsquo;s one final feature that I\u0026rsquo;m really missing: seeing which role players were assigned! As long as I stick around long enough, the server displays a post-game summary that reveals all the role assignments. I can access this at the beginning of playback by peeking through the packet queue and checking the message opcode until I discover the correct packet:\n// ... in Replay.cs public static AfterGameScreenDataMessage PostGameSummary { get; private set; } public static AfterGameScreenDataMessage GetPostGameSummary() { ReceivedPacket postGamePacket = replayablePackets.Where((pkt) =\u0026gt; { byte[] data = Convert.FromBase64String(pkt.payloadBase64); MessageType type = (MessageType) data[0]; return type == MessageType.AfterGameScreenData; }).FirstOrDefault(); if (postGamePacket.Equals(null)) { return null; } byte[] data = Convert.FromBase64String(packet.payloadBase64); return new AfterGameScreenDataMessage(data); } public static void StartPlayback(String filePath) { // ... PostGameSummary = GetPostGameSummary(); } Rendering this information with Dear ImGui is a piece of cake:\n// ... in GUI/Overlays/ReplayPostGameOverlay.cs public static void Render() { if (Replay.IsPlaybackActive \u0026amp;\u0026amp; Replay.PostGameSummary == null) { return; } ImGui.SetNextWindowBgAlpha(0.75f); ImGuiWindowFlags windowFlags = ImGuiWindowFlags.None; windowFlags |= ImGuiWindowFlags.AlwaysAutoResize; windowFlags |= ImGuiWindowFlags.NoFocusOnAppearing; windowFlags |= ImGuiWindowFlags.NoNav; if (ImGui.Begin(\u0026#34;Replay: Post-game\u0026#34;, windowFlags)) { ImGuiTableFlags tableFlags = ImGuiTableFlags.None; tableFlags |= ImGuiTableFlags.Borders; tableFlags |= ImGuiTableFlags.Resizable; if (ImGui.BeginTable(\u0026#34;table_postgame_players\u0026#34;, 4, tableFlags)) { ImGui.TableSetupColumn(\u0026#34;Position\u0026#34;, ImGuiTableColumnFlags.DefaultSort); ImGui.TableSetupColumn(\u0026#34;Nick\u0026#34;); ImGui.TableSetupColumn(\u0026#34;Account\u0026#34;); ImGui.TableSetupColumn(\u0026#34;Roles\u0026#34;); ImGui.TableHeadersRow(); GameRules gameRules = GlobalServiceLocator.GameRulesService.GetGameRules(); foreach (EndGamePartyMemberInfo info in Replay.PostGameSummary.PlayerList.OrderBy(x =\u0026gt; x.Position)) { ImGui.TableNextRow(); ImGui.TableSetColumnIndex(0); ImGui.Text(\u0026#34;\u0026#34; + (info.Position + 1)); ImGui.TableSetColumnIndex(1); ImGui.Text(info.OriginalName); ImGui.TableSetColumnIndex(2); ImGui.Text(info.AccountName); ImGui.TableSetColumnIndex(3); Role role = null; gameRules.Roles.TryGetValue(info.BeginningRoleId, out role); ImGui.TextColored(role.Color.ToVec4(), role.Name); } ImGui.EndTable(); } } } Works like a charm!\nFuture Changes The last remaining problem with this approach is that it lacks some client-side state replication. Since the recording only stores inbound packets from the server, all stateful UI interaction (typing messages, writing notes, selecting targets) is lost.\nIn the future, I plan to address this by tracking each of these in more detail and inserting them as meta-packets inside the recording that require special handling by the playback emulator. However, I\u0026rsquo;m very pleased with the current result, so those changes will have to wait for another day.\n","permalink":"http://localhost:1313/posts/town-of-salem-replay/","tags":null,"title":"Building a Replay System for Town of Salem"},{"categories":null,"content":"Here\u0026rsquo;s how I was able to get ImGui\rworking inside the Unity game engine from a .NET mod loaded with BepInEx\r.\nImGuiRenderingPlugin\rperforms the heavy lifting of hooking the relevant graphics interface and acts as an ImGui backend. ImGui.NET\ris used as a wrapper around the native front-end provided by cimgui\r.\nDependency Setup With BepInEx already installed, I built the example project and set up a post-build task to copy it to \u0026lt;Game\u0026gt;/BepInEx/plugins/ImGuiMod/Mod.dll. Inside that directory, I needed to provide some dependent Mono libraries which were not already included in the \u0026lt;Game\u0026gt;/\u0026lt;Game\u0026gt;_Data/Managed/ directory: System.Runtime.dll and System.Runtime.CompilerServices.Unsafe.dll. The versions of these libraries provided with the repository are unsuitable (System.Runtime.dll is a facade with no actual implementation, System.Runtime.CompilerServices.Unsafe.dll is a .NET build which is unsuitable to link against the Mono libraries provided by Unity game installs) so I replaced them with compatible counterparts. I installed Mono 6.12.0 and searched C:\\Program Files\\Mono\\lib\\mono to locate them, but a different release version might be required depending on the age of the game.\nImGuiRenderingPlugin needs to be able to perform hooking via Unity\u0026rsquo;s native plugin API, so I had to use the third-party tool bundled in the repo to patch \u0026lt;Game\u0026gt;_Data/globalgamemanagers to load both \u0026lt;Game\u0026gt;_Data/Plugins/cimgui.dll and \u0026lt;Game\u0026gt;_Data/Plugins/ImGuiRenderingPlugin.dll during initialization.\nDebugging and Refactoring At this point, the example plugin was successfully rendering ImGui inside the process, but improper state management caused rendering to break between scene changes. Let me explain how the existing code worked:\nTrainerLoader creates a GameObject with TrainerMenu attached TrainerMenu uses Unity\u0026rsquo;s GUI to create a button that does the following steps when clicked If the ImGuiPluginHook GameObject + component pair was not initialized yet, create it. (This bridges our code and ImGuiRenderingPlugin.dll) Also, add the ImGuiDemoWindow component to the active camera, and subscribe to its Layout event to call TrainerMenu.OnLayout ImGuiPluginHook checks if the ImGuiDemoWindow component exists on the active camera and adds it where absent ImGuiDemoWindow implements Update() and simply invokes its Layout event This was really frustrating to debug on account of how confusing it was to include all these moving parts for no apparent benefit. I avoided listing anything but the key elements for the sake of brevity. Ultimately, the problem stemmed from ImGuiDemoWindow\u0026rsquo;s event not being subscribed by TrainerMenu when ImGuiPluginHook re-applied a new ImGuiDemoWindow component to the new scene camera. ImGuiPluginHook is only initialized once (due to DontDestroyOnLoad preserving it between scene changes) and thus TrainerMenu is never able to subscribe to the new event.\nHere\u0026rsquo;s what I did to fix that:\nDelete TrainerLoader Move ImGuiPluginHook GameObject + component initialization to BepInLoader.cs during the mod initialization Delete the TrainerMenu component Rename ImGuiDemoWindow to ImGuiActiveWindow and delete everything inside Implement ImGuiActiveWindow.Update() and use it to execute my ImGui code The modding framework executes the mod through BepInLoader which creates ImGuiPluginHook. During the next frame, ImGuiPluginHook creates and attaches the ImGuiActiveWindow component to the active scene camera. ImGuiActiveWindow calls a static method to render the GUI in its Update function each frame. When the scene changes and deletes the camera, ImGuiPluginHook automatically kicks in and we\u0026rsquo;re back to rendering two frames later.\nInput Fall-through The final problem: ImGui inputs were \u0026ldquo;falling-through\u0026rdquo; to Unity UI elements without being consumed. I\u0026rsquo;m not very familiar with Unity, but I was able to accomplish a simple hack that fixes this well.\n// ImGuiInput.cs public void UpdateMouse() { // ... // disable input events when ImGui is focused var inputModule = EventSystem.current?.currentInputModule; if (inputModule != null) { if (inputModule.isActiveAndEnabled \u0026amp;\u0026amp; WantCaptureMouse) { inputModule.DeactivateModule(); } else if (!inputModule.isActiveAndEnabled \u0026amp;\u0026amp; !WantCaptureMouse) { inputModule.ActivateModule(); } } } This prevents key inputs from being processed by the game as long as ImGui is trying to trap the mouse. However, the game will lose keyboard focus when the mouse is moved over an ImGui element. It works well enough in practice that I haven\u0026rsquo;t been bothered by it.\n","permalink":"http://localhost:1313/posts/imgui-in-unity/","tags":null,"title":"Dear ImGui with .NET in Unity"},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.es/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.fr/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.hi/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.jp/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.pl/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.ru/","tags":null,"title":""},{"categories":null,"content":"","permalink":"http://localhost:1313/search/_index.zh-cn/","tags":null,"title":""}]