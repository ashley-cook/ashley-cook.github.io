<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>Building a Replay System for Town of Salem :: Ashley&#39;s Project Blog - Example site for hugo-theme-tailwind</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta
  name="description"
  content="Town of Salemis an online multiplayer social deduction video game based on the Mafiaparty game. The game is characterized by rapid rounds of quick judgements and information asymmetries. Confusion is a resource, strategy is a sword, and expectation is a weakness. Being able to review previous games and study how each choice you made determined your opportunities and outcomes would be of great advantage in refining game skill."
/>
<meta
  name="keywords"
  content="hugo, tailwind, tailwindcss, hugo theme, hugo theme tailwind"
/>
<meta name="robots" content="noodp" />
<meta property="og:url" content="http://localhost:1313/posts/town-of-salem-replay/">
  <meta property="og:site_name" content="Ashley&#39;s Project Blog">
  <meta property="og:title" content="Building a Replay System for Town of Salem">
  <meta property="og:description" content="Town of Salemis an online multiplayer social deduction video game based on the Mafiaparty game. The game is characterized by rapid rounds of quick judgements and information asymmetries. Confusion is a resource, strategy is a sword, and expectation is a weakness. Being able to review previous games and study how each choice you made determined your opportunities and outcomes would be of great advantage in refining game skill.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-14T13:12:57-07:00">
    <meta property="article:modified_time" content="2024-06-14T13:12:57-07:00">


  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Building a Replay System for Town of Salem">
  <meta name="twitter:description" content="Town of Salemis an online multiplayer social deduction video game based on the Mafiaparty game. The game is characterized by rapid rounds of quick judgements and information asymmetries. Confusion is a resource, strategy is a sword, and expectation is a weakness. Being able to review previous games and study how each choice you made determined your opportunities and outcomes would be of great advantage in refining game skill.">


<link rel="canonical" href="http://localhost:1313/posts/town-of-salem-replay/" />

<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/css/index.e35987a77152345c1efaebd6ce6240488de0f6d5a0c1d19a843ff32bba9f70bb.css">





  






  
  

</head>
<body class="flex flex-col min-h-screen w-full bg-slate-50 dark:bg-gray-800">
    
<div class="fixed right-0 top-0 z-50 flex items-center justify-center bg-gray-200 p-2 text-sm uppercase text-black sm:bg-red-200 md:bg-yellow-200 lg:bg-green-200 xl:bg-blue-200 2xl:bg-pink-200">
  <span class="block sm:hidden">all</span>
  <span class="hidden sm:block md:hidden">sm</span>
  <span class="hidden md:block lg:hidden">md</span>
  <span class="hidden lg:block xl:hidden">lg</span>
  <span class="hidden xl:block 2xl:hidden">xl</span>
  <span class="hidden 2xl:block">2xl</span>
</div>

  <header class="flex flex-none justify-center z-10">
    <div class="flex flex-row gap justify-between w-full max-w-4xl lg:max-w-5xl h-12 mt-3">
  <div class="flex-none ml-2 md:ml-0">
    <a href="/" class="">
      <img class="h-12 w-12 rounded-full object-cover bg-gray-100" src="/logo.png" alt="logo">
    </a>
  </div>
  <div class="flex-1"></div>
  <div class="flex-none">
    



<nav class="h-full static">
  <button id="navbar-menu-toggle" type="button" class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg md:hidden" aria-controls="navbar-menu" aria-expanded="false">
    <span class="sr-only">Open main menu</span>
    <i class="w-8 h-8">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-menu-2" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 6l16 0" />
  <path d="M4 12l16 0" />
  <path d="M4 18l16 0" />
</svg>

    </i>
  </button>
  <div class="absolute md:static top-16 left-0 right-0 z-50 hidden w-full md:block md:w-auto" id="navbar-menu">
    <ul class="flex flex-col mx-2 md:mx-0 md:flex-row md:border-0 rounded-sm md:rounded-full px-3 text-base font-medium text-slate-800 dark:text-slate-200 shadow-lg bg-white dark:bg-gray-600 shadow-slate-800/5 dark:shadow-slate-200/5 ring-1 ring-slate-900/5 dark:ring-slate-100/5">
    
        <li id="about" class="">
          <a class="block px-3 py-3 hover:text-emerald-600"
            href="" title="About">About</a>
        </li>
      
    
        <li id="post" class="">
          <a class="block px-3 py-3 hover:text-emerald-600 text-emerald-600"
            href="/posts/" title="Post">Post</a>
        </li>
      
    
    </ul>
  </div>
</nav>


  </div>
  
  <div class="flex-none mx-1"></div>
  
  <div class="flex-none md:hidden">
    <a href=/search/ class="inline-flex items-center p-2 text-sm text-slate-800 dark:text-slate-200 rounded-lg" aria-controls="navbar-menu" aria-expanded="false">
      <span class="sr-only">Search</span>
      <i class="w-8 h-8">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
    <path stroke="none" d="M0 0h24v24H0z" fill="none" />
    <path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" />
    <path d="M21 21l-6 -6" />
</svg>

      </i>
    </a>
  </div>
  <div class="darkmode-toggle flex flex-none mr-2 md:mr-0">
    <label for="darkmode-toggle" class="flex items-center px-3 cursor-pointer rounded-full bg-gray-100 dark:bg-gray-600" title="Toggle dark mode">
      <input name="darkmode-toggle" id="darkmode-toggle" type="checkbox" class="sr-only peer" aria-label="Toggle dark mode">
      <div class="group flex flex-row gap-1 justify-center h-8 px-1 rounded-full bg-white dark:bg-gray-700">
        <i class="h-6 w-6 flex-none rounded-full bg-yellow-400 place-self-center peer-checked:group-[]:invisible">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brightness-down" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0"></path>
   <path d="M12 5l0 .01"></path>
   <path d="M17 7l0 .01"></path>
   <path d="M19 12l0 .01"></path>
   <path d="M17 17l0 .01"></path>
   <path d="M12 19l0 .01"></path>
   <path d="M7 17l0 .01"></path>
   <path d="M5 12l0 .01"></path>
   <path d="M7 7l0 .01"></path>
</svg>

        </i>
        <i class="h-6 w-6 flex-none rounded-full place-self-center invisible peer-checked:group-[]:visible">
          <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-moon-stars" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z"></path>
   <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2"></path>
   <path d="M19 11h2m-1 -1v2"></path>
</svg>

        </i>
      </div>
    </label>
  </div>
</div>

  </header>
  <main class="flex flex-auto justify-center">
    
<div class="w-full max-w-4xl lg:max-w-5xl">
  <div class="flex flex-col mt-6 mx-2 md:mx-0 rounded-lg overflow-hidden shadow-md bg-white dark:bg-gray-700">
    <div>
      <a href="/posts/town-of-salem-replay/">
        
      </a>
    </div>
    <div class="flex flex-col gap-y-3 p-6">
      <h1 class="text-4xl font-semibold text-slate-800 dark:text-slate-100">
        <a href="/posts/town-of-salem-replay/">Building a Replay System for Town of Salem</a>
      </h1>

      
      


      <div class="flex flex-col gap-y-1 md:flex-row md:gap-y-0 md:gap-x-4 text-slate-500 dark:text-slate-300">
  
  
  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M4 7a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2v-12z"></path>
   <path d="M16 3v4"></path>
   <path d="M8 3v4"></path>
   <path d="M4 11h16"></path>
   <path d="M11 15h1"></path>
   <path d="M12 15v3"></path>
</svg>

    </i>
    <time datetime="2024-06-14T13:12:57-07:00">
      2024-06-14
    </time>
  </div>

  <div class="flex flex-row text-base gap-x-1">
    <i class="h-6 w-6 flex-none">
      <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hourglass-high" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M6.5 7h11"></path>
   <path d="M6 20v-2a6 6 0 1 1 12 0v2a1 1 0 0 1 -1 1h-10a1 1 0 0 1 -1 -1z"></path>
   <path d="M6 4v2a6 6 0 1 0 12 0v-2a1 1 0 0 0 -1 -1h-10a1 1 0 0 0 -1 1z"></path>
</svg>

    </i>
    <span>
      9 minutes to read
    </span>
  </div>
</div>


      
        
        <section class="prose prose-slate dark:prose-invert w-full max-w-4xl lg:max-w-5xl mt-6">
          <h2>Table of Contents</h2>
          <aside><nav id="TableOfContents">
  <ul>
    <li><a href="#assessment">Assessment</a></li>
    <li><a href="#technical-approach">Technical Approach</a></li>
    <li><a href="#network-overview">Network Overview</a></li>
    <li><a href="#building-the-perfect-beast">Building the Perfect Beast</a>
      <ul>
        <li><a href="#recording-format">Recording Format</a></li>
        <li><a href="#saving-and-loading">Saving and Loading</a></li>
        <li><a href="#emulating-realtime-playback">Emulating Realtime Playback</a></li>
        <li><a href="#further-tweaks">Further Tweaks</a></li>
        <li><a href="#final-improvement">Final Improvement</a></li>
      </ul>
    </li>
    <li><a href="#future-changes">Future Changes</a></li>
  </ul>
</nav></aside>
        </section>
        
      

      <article class="mt-6 w-full max-w-4xl lg:max-w-5xl prose prose-slate dark:prose-invert prose-quoteless post-content">
        <p><a href="https://www.blankmediagames.com/" target="_blank" rel="noopener">Town of Salem</a>
 is an online multiplayer social deduction video game based on
the <a href="https://en.wikipedia.org/wiki/Mafia_%28party_game%29" target="_blank" rel="noopener">Mafia</a>
 party game. The game is characterized by rapid
rounds of quick judgements and information asymmetries. Confusion is a resource, strategy is a sword, and
expectation is a weakness. Being able to review previous games and study how each choice you made determined your opportunities and
outcomes would be of great advantage in refining game skill.</p>
<h2 id="assessment">Assessment</h2>
<p>The Steam distribution of the game is written in the <a href="https://unity.com/" target="_blank" rel="noopener">Unity</a>
 game engine and compiled into .NET assemblies
which are loaded and executed by the engine at runtime. This means that we&rsquo;re
able to decompile the game code with nearly one-to-one accuracy. Owing to the
high success rate of lossless transpiling of Intermediate Language bytecode,
many games written in Unity opt to obfuscate their release assemblies,
especially since many development teams choose to externalize costs at the
expense of the players by making cheating both possible and easy.</p>
<p>Upon reviewing the primary assembly for Town of  Salem, no obfuscation is employed. The networking code is engineered
to prevent players from exploiting the game with client-side modifications. This is valuable in our case, as it
means that we&rsquo;ll be able to record network traffic during live games and simply feed everything back in later.
Effectively no interaction on the client is necessary to progress the state of the game. Additionally, the lack
of obfuscation will make the general task of writing a mod much easier.</p>
<h2 id="technical-approach">Technical Approach</h2>
<p>I&rsquo;ve opted to use an existing modding framework called <a href="https://github.com/BepInEx/BepInEx" target="_blank" rel="noopener">BepInEx</a>
. It utilizes
DLL hijacking to perform the necessary redirections, which is important as it means we&rsquo;ll almost never need to
update the mod or re-patch existing files after a game update. It also provides a
<a href="https://github.com/BepInEx/HarmonyX" target="_blank" rel="noopener">custom patching library</a>
, which will allow me to easily patch the network
management code. I&rsquo;ll also be working from the GUI system referenced in my <a href="posts/imgui-in-unity/">previous post</a>
.</p>
<h2 id="network-overview">Network Overview</h2>
<p>The networking layer is directed through a small class <code>TOSNetworkService</code>. This class is responsible for managing
the lifetime of the TCP socket, testing the health of the connection, and serializing/deserializing network traffic.
The latter task is the most relevant, since I&rsquo;ll want to both save raw game traffic to disk and prevent the
client from attempting to send traffic during replay playback.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TOSNetworkService</span> : INetworkService 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ProcessMessages(<span style="color:#66d9ef">byte</span>[] data) {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SendMessage(Client.BaseMessage msg) {}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since the networking protocol is so straightforward, the reverse-engineering part of the project is over
almost instantly.</p>
<h2 id="building-the-perfect-beast">Building the Perfect Beast</h2>
<p>I only need a few points of interface for replay management, so I&rsquo;ll start by defining those externally-accessible
methods immediately.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Replay</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsRecording { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsPlaybackActive { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> IsPlaybackPaused { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> OnServerPacket(<span style="color:#66d9ef">byte</span>[] data);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StartPlayback(String filePath);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StopPlayback();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> TogglePlayback();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The requisite patches are very simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#a6e22e">[HarmonyPatch(typeof(TOSNetworkService))]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PatchTOSNetworkService</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPatch(nameof(TOSNetworkService.ProcessMessages))]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPatch(new Type[]</span> { <span style="color:#66d9ef">typeof</span>(<span style="color:#66d9ef">byte</span>[]) })]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPrefix]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> PrefixProcessMessages(<span style="color:#66d9ef">ref</span> <span style="color:#66d9ef">byte</span>[] data)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        Replay.OnServerPacket(data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    
</span></span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPatch(nameof(TOSNetworkService.SendMessage))]</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPatch(new Type[]</span> { <span style="color:#66d9ef">typeof</span>(BaseMessage) })]
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">    [HarmonyPrefix]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> PrefixSendMessage(<span style="color:#66d9ef">ref</span> BaseMessage msg)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// suppress outbound network traffic when replay files are loaded</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> !Replay.IsPlaybackActive;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="recording-format">Recording Format</h3>
<p>For recording, I need to capture an array of raw network messages with the time in milliseconds after the start
of the recording that they were received. The playback mechanism is simple: start a timer and check the packet
queue each game tick to determine if the next packet should be processed according to its stored delay.
Fine-grained playback control can be further built on top of that core system later.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ReceivedPacket</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> millisecondDelay;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> String payloadBase64;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Recording</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> startTimeUnixMilli;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">long</span> lengthInMilliseconds;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> List&lt;ReceivedPacket&gt; packets;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> DateTime startTime;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Stopwatch stopwatch = <span style="color:#66d9ef">new</span> Stopwatch();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> List&lt;ReceivedPacket&gt; packetLog;
</span></span></code></pre></div><p>I want to automatically begin recording each time a game starts and stop recording when it ends. That&rsquo;s simple:
I can watch the packet stream to capture these events.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> OnServerPacket(<span style="color:#66d9ef">byte</span>[] data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsPlaybackActive)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    MessageType messageType = (MessageType) data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (messageType == MessageType.CreateLobby)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        StartRecording();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (IsRecording)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        packetLog.Add(<span style="color:#66d9ef">new</span> ReceivedPacket()
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            millisecondDelay = stopwatch.ElapsedMilliseconds,
</span></span><span style="display:flex;"><span>            payloadBase64 = Convert.ToBase64String(data, Base64FormattingOptions.None)
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (messageType == MessageType.ReturnToHome)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        StopRecording();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Wonderful! The simplicity of the network protocol implementation means that I don&rsquo;t have to worry anything like
frame delimitation, which can get very complicated depending on the composition of the protocol.</p>
<h3 id="saving-and-loading">Saving and Loading</h3>
<p>Next up, serializing the recording and writing to disk. I could come up with a low-level format to store
recordings in a space-efficient manner, but it won&rsquo;t be a cost-effective use of my time. The network protocol
is already rather sparse, since there&rsquo;s nothing to communicate except the bare gameplay fundamentals. It would also
make further changes to the recording format somewhat frustrating. By using JSON, I&rsquo;m able to use existing
libraries to serialize and deserialize C# objects in a flash while ignoring object fields that are not present
in a given recording file. Simple code is more flexible and less prone to failure!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StopRecording()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (!IsRecording)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// determine file name</span>
</span></span><span style="display:flex;"><span>    TimeSpan epochTimeSpan = startTime.ToUniversalTime() - <span style="color:#66d9ef">new</span> DateTime(<span style="color:#ae81ff">1970</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">long</span> epochMillis = (<span style="color:#66d9ef">long</span>) epochTimeSpan.TotalMilliseconds;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> fileName = String.Format(<span style="color:#e6db74">&#34;replay/{0}.json&#34;</span>, epochMillis);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// populate the recording struct</span>
</span></span><span style="display:flex;"><span>    Recording recording = <span style="color:#66d9ef">new</span> Recording();
</span></span><span style="display:flex;"><span>    recording.startTimeUnixMilli = epochMillis;
</span></span><span style="display:flex;"><span>    recording.lengthInMilliseconds = (<span style="color:#66d9ef">long</span>) DateTime.Now.Subtract(startTime).TotalMilliseconds;
</span></span><span style="display:flex;"><span>    recording.packets = packetLog;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// serialize the recording and write to disk</span>
</span></span><span style="display:flex;"><span>    Directory.CreateDirectory(<span style="color:#e6db74">&#34;replay&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> json = Newtonsoft.Json.JsonConvert.SerializeObject(recording);
</span></span><span style="display:flex;"><span>    File.WriteAllText(fileName, json);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    IsRecording = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StartRecording(String filePath)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Recording recording = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Recording&gt;(File.ReadAllText(filePath));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="emulating-realtime-playback">Emulating Realtime Playback</h3>
<p>Earlier, I said the phrase &ldquo;packet queue&rdquo; as a means of conceptualizing the received server traffic, so I&rsquo;ll create a <code>Queue&lt;ReceivedPacket&gt;</code> to store packets from the
loaded recording file. Since each packet is stored with the millisecond delay it was received after recording,
and since each packet was serialized in the order it was received, emulating linear playback is simply a matter
of checking the packet at the front of the queue and comparing it to the playback timer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Queue&lt;ReceivedPacket&gt; replayablePackets = <span style="color:#66d9ef">new</span> Queue&lt;ReceivedPacket&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StartPlayback(String filePath)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Recording recording = Newtonsoft.Json.JsonConvert.DeserializeObject&lt;Recording&gt;(File.ReadAllText(filePath));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    replayablePackets.Clear();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span> (ReceivedPacket packet <span style="color:#66d9ef">in</span> recording.packets)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        replayablePackets.Enqueue(packet);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    stopwatch.Restart();
</span></span><span style="display:flex;"><span>    playbackOffset = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    IsPlaybackActive = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    IsPlaybackPaused = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> TickPlayback() 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (replayablePackets.Count &gt; <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>        &amp;&amp; replayablePackets.Peek().millisecondDelay &lt;= stopwatch.ElapsedMilliseconds
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ReceivedPacket packet = replayablePackets.Dequeue();
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">byte</span>[] data = Convert.FromBase64String(packet.payloadBase64);
</span></span><span style="display:flex;"><span>        TOSNetworkService networkService = (TOSNetworkService) GlobalServiceLocator.Instance.NetworkService;
</span></span><span style="display:flex;"><span>        networkService.ProcessMessages(data);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I also mentioned checking the packet queue each game tick, so I&rsquo;ll need to utilize my <code>BepInLoader</code> class
(which extends Unity&rsquo;s <code>MonoBehavior</code> class, and is thus integrated into the engine&rsquo;s ECS implementation) to
execute the playback logic in the main thread.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BepInLoader</span> : BaseUnityPlugin
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">event</span> Action OnUpdate;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> Update()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (OnUpdate != <span style="color:#66d9ef">null</span>) 
</span></span><span style="display:flex;"><span>        {    
</span></span><span style="display:flex;"><span>            OnUpdate();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Replay</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StartPlayback() 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        BepInLoader.OnUpdate += TickPlayback;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StopPlayback()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        BepInLoader.OnUpdate -= TickPlayback;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="further-tweaks">Further Tweaks</h3>
<p>With all of this done, simple playback works better than I had expected. I was able to toggle the playback state
by simply stopping and starting the <code>Stopwatch</code> object, but sometimes there are long pauses that I&rsquo;d rather skip.
I need to come up with a way to skip the timer ahead so that I can force the next packet to be processed immediately.</p>
<p>Since the <code>Stopwatch</code> class doesn&rsquo;t expose any methods to modify the time, I&rsquo;ll have to track the time offset
independently.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> Queue&lt;ReceivedPacket&gt; replayablePackets = <span style="color:#66d9ef">new</span> Queue&lt;ReceivedPacket&gt;();
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">long</span> playbackOffset = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> SkipPacket()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (PlaybackActive &amp;&amp; replayablePackets.Count &gt; <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ReceivedPacket packet = replayablePackets.Peek();
</span></span><span style="display:flex;"><span>        playbackOffset = packet.millisecondDelay - stopwatch.ElapsedMilliseconds;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> TickPlayback()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (replayablePackets.Count &gt; <span style="color:#ae81ff">0</span> 
</span></span><span style="display:flex;"><span>        &amp;&amp; replayablePackets.Peek().millisecondDelay &lt;= (stopwatch.ElapsedMilliseconds + playbackOffset))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Initially, I ran into a bug with this approach where the playback seemed to jump ahead much further than expected.
It wasn&rsquo;t quite until I realized that the problem worsened during later playback time that I realized my issue:
I had forgotten to compensate for the amount of time that had already elapsed. Simply subtracting
<code>stopwatch.ElapsedMilliseconds</code> from <code>packet.millisecondDelay</code> corrected the issue.</p>
<h3 id="final-improvement">Final Improvement</h3>
<p>Now that recording and playback are working without issue, I&rsquo;m able to review previous games and study my mistakes.
Yet, there&rsquo;s one final feature that I&rsquo;m really missing: seeing which role players were assigned! As long as I
stick around long enough, the server displays a post-game summary that reveals all the role assignments. I can
access this at the beginning of playback by peeking through the packet queue and checking the message opcode
until I discover the correct packet:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in Replay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> AfterGameScreenDataMessage PostGameSummary { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> AfterGameScreenDataMessage GetPostGameSummary()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ReceivedPacket postGamePacket = replayablePackets.Where((pkt) =&gt;
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">byte</span>[] data = Convert.FromBase64String(pkt.payloadBase64);
</span></span><span style="display:flex;"><span>        MessageType type = (MessageType) data[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> type == MessageType.AfterGameScreenData;
</span></span><span style="display:flex;"><span>    }).FirstOrDefault();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (postGamePacket.Equals(<span style="color:#66d9ef">null</span>))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">byte</span>[] data = Convert.FromBase64String(packet.payloadBase64);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> AfterGameScreenDataMessage(data);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> StartPlayback(String filePath)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    PostGameSummary = GetPostGameSummary();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Rendering this information with Dear ImGui is a piece of cake:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// ... in GUI/Overlays/ReplayPostGameOverlay.cs</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> Render()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (Replay.IsPlaybackActive &amp;&amp; Replay.PostGameSummary == <span style="color:#66d9ef">null</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ImGui.SetNextWindowBgAlpha(<span style="color:#ae81ff">0.75f</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ImGuiWindowFlags windowFlags = ImGuiWindowFlags.None;
</span></span><span style="display:flex;"><span>    windowFlags |= ImGuiWindowFlags.AlwaysAutoResize;
</span></span><span style="display:flex;"><span>    windowFlags |= ImGuiWindowFlags.NoFocusOnAppearing;
</span></span><span style="display:flex;"><span>    windowFlags |= ImGuiWindowFlags.NoNav;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (ImGui.Begin(<span style="color:#e6db74">&#34;Replay: Post-game&#34;</span>, windowFlags))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        ImGuiTableFlags tableFlags = ImGuiTableFlags.None;
</span></span><span style="display:flex;"><span>        tableFlags |= ImGuiTableFlags.Borders;
</span></span><span style="display:flex;"><span>        tableFlags |= ImGuiTableFlags.Resizable;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (ImGui.BeginTable(<span style="color:#e6db74">&#34;table_postgame_players&#34;</span>, <span style="color:#ae81ff">4</span>, tableFlags))
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            ImGui.TableSetupColumn(<span style="color:#e6db74">&#34;Position&#34;</span>, ImGuiTableColumnFlags.DefaultSort);
</span></span><span style="display:flex;"><span>            ImGui.TableSetupColumn(<span style="color:#e6db74">&#34;Nick&#34;</span>);
</span></span><span style="display:flex;"><span>            ImGui.TableSetupColumn(<span style="color:#e6db74">&#34;Account&#34;</span>);
</span></span><span style="display:flex;"><span>            ImGui.TableSetupColumn(<span style="color:#e6db74">&#34;Roles&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ImGui.TableHeadersRow();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            GameRules gameRules = GlobalServiceLocator.GameRulesService.GetGameRules();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">foreach</span> (EndGamePartyMemberInfo info <span style="color:#66d9ef">in</span> Replay.PostGameSummary.PlayerList.OrderBy(x =&gt; x.Position))
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                ImGui.TableNextRow();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                ImGui.TableSetColumnIndex(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>                ImGui.Text(<span style="color:#e6db74">&#34;&#34;</span> + (info.Position + <span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                ImGui.TableSetColumnIndex(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>                ImGui.Text(info.OriginalName);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                ImGui.TableSetColumnIndex(<span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>                ImGui.Text(info.AccountName);
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                ImGui.TableSetColumnIndex(<span style="color:#ae81ff">3</span>);
</span></span><span style="display:flex;"><span>                Role role = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span>                gameRules.Roles.TryGetValue(info.BeginningRoleId, <span style="color:#66d9ef">out</span> role);
</span></span><span style="display:flex;"><span>                ImGui.TextColored(role.Color.ToVec4(), role.Name);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            ImGui.EndTable();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Works like a charm!</p>
<p><div class="not-prose">
<figure>
    <img src="/images/posts/town-of-salem-replay/summary_overlay.png"
      alt="ImGui window rendering the post-game summary of the active replay" 
      loading="lazy"
    >
  </figure></div>
</p>
<h2 id="future-changes">Future Changes</h2>
<p>The last remaining problem with this approach is that it lacks some client-side state replication. Since the
recording only stores inbound packets from the server, all stateful UI interaction (typing messages, writing notes,
selecting targets) is lost.</p>
<p>In the future, I plan to address this by tracking each of these in more detail
and inserting them as meta-packets inside the recording that require special handling by the playback emulator.
However, I&rsquo;m very pleased with the current result, so those changes will have to wait for another day.</p>

      </article>

      




    </div>
  </div>
</div>

  </main>
  <footer class="flex flex-none justify-center">
    <section class="flex flex-col md:flex-row mx-2 md:mx-0 gap-2 md:gap-0 justify-between w-full max-w-4xl lg:max-w-5xl py-6 text-slate-500 dark:text-slate-300">
  <div class="flex flex-row">
    
  
  
  
  
  
  
  
  
  
  
  


  </div>
  <div class="grow"></div>
  <div class="flex flex-row">
    <i class="h-6 w-6 flex-none"><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
   <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
   <path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path>
   <path d="M14 9.75a3.016 3.016 0 0 0 -4.163 .173a2.993 2.993 0 0 0 0 4.154a3.016 3.016 0 0 0 4.163 .173"></path>
</svg>
</i> 2023 - 2024 Ashley Cook
    
  </div>
  
  <div class="flex flex-row">
    <span class="ml-0 pl-0 md:ml-2 md:pl-2 border-l-0 md:border-l border-slate-300 dark:border-slate-400">
      Powered by <a href="https://gohugo.io" target="_blank" rel="noopener" class="underline">Hugo</a> <span class="text-red-600">&hearts;</span> <a href="https://github.com/tomowang/hugo-theme-tailwind" target="_blank" rel="noopener" class="underline">Tailwind</a>
    </span>
  </div>
  
</section>

  </footer>
  <script src="/main.js"></script>

<div class="hidden top-1 right-1" id="code-copy">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copy" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" />
  <path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" />
</svg>

  </i>
</div>
<div class="hidden top-1 right-1" id="code-copy-done">
  <i class="h-6 w-6 block">
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-check" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M5 12l5 5l10 -10" />
</svg>

  </i>
</div><script src="/code-copy.js"></script>





</body>
</html>
